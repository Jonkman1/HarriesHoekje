
title: "R als een Gis"
description: |
  Over ruimtelijke data en het gebruik van R als een GIS
author:
  - name: Harrie Jonkman
    url: www.harriejonkman.nl
date: 12-15-2019
output:
  distill::distill_article:
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## Introduction to Spatial Data & Using R as a GIS

Dit is een bewerking en verkorte versie van de tutorial die Nick Bearman eerder schreef (Introduction to Spatial Data & Using R as a GIS) en die vrij toegankelijk is [hier](https://github.com/nickbearman/intro-r-spatial-analysis). De data die in deze tutorial worden gebruikt zijn eigen data of open data ook om de techniek goed onder de knie te krijgen. Dank je wel Nick Bearman.


## Eindtermen:	R Functies & Bibliotheken:
 
- R gebruiken om CSV data in te lezen: read.csv()  
- R gebruiken om ruimtelijke gegevens in te lezen: st_read() 
- Weten hoe ruimtelijke gegevens te plotten met behulp van R: qtm() & tm_shape()  
- Weten hoe je kleuren en classificaties moet aanpassen: style 
- Begrijpen hoe je loops moet gebruiken om meerdere kaarten te maken: for(){} 
- Weten hoe je ruimtelijke gegevens opnieuw geprojecteerd krijgt: st_transform()  
- In staat zijn om punten te gebruiken in veelhoekanalyse: poly.counts() 
- Weten hoe je shapefiles moet opslaan: st_write() 

## Intro op R & GIS
### R Basis
R begon als een statistisch programma en wordt nog steeds door veel gebruikers als een programma gebruikt. We gaan een programma gebruiken dat RStudio heet, dat bovenop R werkt en een goede gebruikersinterface biedt. Ik zal het in de presentatie even hebben over RStudio, en de belangrijkste gebieden van het venster zijn op de achterzijde gemarkeerd.

- Open RStudio (klik op Start en typ RStudio in of dubbelklik op het icoontje op het bureaublad).
R kan in eerste instantie als rekenmachine worden gebruikt - voer het volgende in de linkerkant van het venster in - het gedeelte met de titel Console:

```{r}
6  + 8
```


Maak je voorlopig geen zorgen over de [1] - let wel dat R 14 heeft afgedrukt, want dit is het antwoord op de som die je hebt ingetikt. In deze werkbladen laat ik soms de resultaten zien van wat je hebt ingetypt, zoals hieronder:


```{r}
 5  * 4	
```

Merk ook op dat `*` hier het symbool voor vermenigvuldiging is - in het laatste commando vroeg R om de berekening `5 maal 4` uit te voeren. Andere symbolen zijn - voor aftrekken en / voor delen:
 
```{r}
12  - 14	
```
 

```{r}
 6  / 17	

```
 

Je kunt de antwoorden van de berekeningen ook toewijzen aan variabelen en gebruiken in berekeningen.

```{r}
 price  <- 300	

```


Hier wordt de waarde 300 opgeslagen in de variabele prijs. Het `<-` symbool betekent dat de waarde rechts in de variabele links in de variabele wordt gezet, deze wordt getypt met een `<<` gevolgd door een `-`. De variabelen worden getoond in het venster met de naam Environment, rechtsboven in het venster. Variabelen kunnen gebruikt worden in volgende berekeningen. Om bijvoorbeeld een korting van 20% op deze prijs toe te passen, kunt je het volgende invoeren:

 
#![Figure 1: Screenshot of RStudio](ScreenShot_1)

```{r}
price - price * 0.2	
```


of gebruik tussenvariabelen:

```{r}
discount<-price*0.2
price-discount
```


R kan ook werken met lijsten met nummers, maar ook met individuele nummers. Lijsten worden gespecificeerd met behulp van de c-functie. Stel dat je een lijst hebt met huizenprijzen in duizenden euro's. Je zou ze kunnen opslaan in een variabele die house.prices genoemd wordt, zoals hieronder:

```{r}
house.prices<-c(120, 150, 212, 99, 199, 299, 159)
house.prices
```

Merk op dat er geen probleem is met punten in het midden van variabelenamen. U kunt dan functies toepassen op deze lijsten.

```{r}
mean(house.prices)
```

Als de huizenprijzen in duizenden euro's zijn, dan zegt dit ons dat de gemiddelde huizenprijs 176.900 EURO bedraagt. Merk op dat het antwoord op jouw scherm meer cijfers kan weergegeven. Dus je kunt iets als 176.8571429 voor gemiddelde waarde hebben.

## Het Dataframe

R heeft een manier om gegevens op te slaan in een object dat een dataframe wordt genoemd. Dit lijkt op een interne spreadsheet.

```{r}
discount <- price * 0.2 
price - discount
```

Waar alle relevante gegevenselementen samen als een set kolommen worden opgeslagen.

We hebben een CSV-bestand van huizenprijzen en inbraakcijfers, dat we in R kunnen laden. We kunnen gebruik maken van een functie genaamd read.csv die, zoals je misschien wel kunt bedenken, CSV-bestanden leest. Voer de onderstaande coderegel uit, die het CSV-bestand in een variabele met de naam hp.data laadt.

# Rotterdam

```{r}
library(readxl)
RotterdamStaat <- read_excel("StaatJeugdKort.xlsx")
```

Als we de gegevens inlezen, is het altijd een goed idee om te controleren of ze goed zijn binnengekomen. Om dit te doen, kunnen we een voorbeeld van de dataset bekijken. Het `head`-commando toont de eerste 6 rijen van de data.


Hieronder lezen we dan ons databestand in.

```{r}
head(RotterdamStaat)
```

Je kunt ook op de variabele in het venster Environment klikken, die de gegevens in een nieuw tabblad zal tonen. Je kunt ook zelf invoeren en een tabblad openen met de gegevens:


```
#Probeer onderstaande, hier niet afgedrukt want dit wordt te lang
View(RotterdamStaat)
```

Je kunt ook elke kolom in de dataset beschrijven met behulp van de `summary`-functie:
 


Item	        Beschrijving
 
Min.	        De kleinste waarde in de kolom
1st. Qu.	Het eerste kwartiel (de waarde 1/4 van de variabele) 
Median	        De mediaan (de waarde 1/2 van de variabele) 
Mean	        Het gemiddelde van de kolom
3rd. Qu.	Het derde kwartiel (de waarde 3/4 van de variabele) 
Max.	        De hoogste waarde in de kolom




```{r}
summary(RotterdamStaat)
```

Voor elke kolom wordt een aantal waarden genoemd:

*Op basis van deze getallen kan een indruk worden verkregen van de spreiding van de waarden van elke variabele.  Met name kan worden vastgesteld dat de mediaan van de huizenprijs in St. Helens per wijk varieert van 65.000 EURO tot 260.000 EURO en dat de helft van de prijzen tussen 152.500 EURO en 210.000 EURO ligt. Ook kan worden vastgesteld dat, aangezien de mediaan van het gemeten inbraakpercentage nul is, ten minste de helft van de gebieden geen inbraken had in de maand waarin de tellingen werden samengesteld.*.


We kunnen vierkante haken gebruiken om specifieke delen van het dataframe te bekijken, bijvoorbeeld hp.data[1,] of hp.data[,1]. We kunnen ook kolommen verwijderen en nieuwe kolommen aanmaken met behulp van de onderstaande code. Vergeet niet om het `head()` commando te gebruiken zoals we eerder deden om naar het dataframe te kijken.


```{r}
#Creeer een nieuwe kolom in de hp.data dataframe en noem deze counciltax, en sla de waarde NA op
RotterdamStaat$counciltax <- NA
#Kijk wat er is gebeurd
head(RotterdamStaat)
```



```{r}
#Verander de naam van deze kolom in "Price-thousands"
colnames(RotterdamStaat)[3] <- "Price-thousands"
#Kijk wat er is gebeurd
head(RotterdamStaat)
```

## Geograpfische Informatie
R heeft zich ontwikkeld tot een GIS waar gebruikers aan hebben bijgedragen met pakketten, of 'libraries' zoals R ze noemt. We zullen in de tutorial verschillende van dit soort 'libraries' gebruiken en zullen ze laden als dat nodig is.

Als u uw computer gebruikt, moet u de R-libraries installeren en ze ook laden. Om dit te doen, start u `install.packages` ("library_name").

Om met ruimtelijke gegevens te kunnen werken, moeten we na dat installeren een aantal 'libraries' laden>


```{r}
#Laden van libraries die we hier gebruiken 
library(sf) 
library(tmap)
library(dplyr)
```


Om met ruimtelijke gegevens te werken, moeten we enkele `libraries` laden. Daarmee is R echter alleen maar in staat om geografische data te verwerken. Het laadt nog geen specifieke data sets. Om dit te doen, moeten we enkele gegevens inlezen. Hiervoor gaan we **shapefiles** gebruiken - een bekend GIS-dataformat. We gaan LSOA(Lower layer Super Output Areas)-data gebruiken voor St. Helens in Merseyside.


R gebruikt werkmappen om informatie op te slaan die relevant is voor het huidige project waaraan je werkt. Ik stel voor dat je een map een bepaalde naam geeft die het R-werk ergens zinvol maakt. Dan moeten we R vertellen waar deze map staat, dus klik op **Session > Set Working Directory > Choose Directory. .** en selecteer de map die je hebt aangemaakt.


Zoals met de meeste programma's, zijn er meerdere manieren om dingen te doen. Om bijvoorbeeld de werkmap in te stellen, kunnen we het volgende typen: setwd("M:/R_werk"). Jouw versie kan een langere titel hebben, afhankelijk van hoe je de map noemt. Merk ook op dat schuine streepjes worden aangegeven met een '/ ' en niet '\'.


Er is een set van shapefiles voor de St. Helens-wijken op dezelfde locatie als de dataset die je eerder hebt gelezen. Omdat er meerdere bestanden nodig zijn, heb ik deze in één zip-bestand gebundeld. Deze download je naar jouw lokale map en pakt deze vervolgens uit. Dit doe je met de volgende R-functies:

```{r}
unzip("Wijkprofiel.zip")
```

De eerste functie downloadt het zip-bestand daadwerkelijk in uw werkmap. De tweede functie pakt het zip-bestand uit. Nu kunnen we het bestand in R lezen.


```{r}
Rotterdam<-st_read("wijkindeling.shp")
```

De st_read functie doet dit en slaat ze op als een Simple Features (of sf) object. Je kunt de qtm-functie gebruiken om de polygonen (d.w.z. de kaart van de LSOA) te tekenen.



```{r}
qtm(Rotterdam)
```


We kunnen ook het head()-commando gebruiken om de eerste zes rijen te tonen, precies hetzelfde als bij een data frame.


```{r}
head(Rotterdam)
```

*Voor degene die met GIS werkt: Dit is hetzelfde als de attribuutentententabel in programma's als ArcGIS, QGIS of MapInfo. Als u het shapefile in QGIS of ArcGIS wilt openen om vast te stellen hoe het er zo'n beetje uit ziet, kunt u dat doen.*


Je kunt zien dat er veel informatie beschikbaar is, inclusief de geometrie. Voor ons is het ID-veld belangrijk, en zien dat dit overeenkomt met het ID-veld in het hp.data bestand. We kunnen dit gebruiken om de twee datasets samen te voegen om de inbraakgegevens op de kaart te tonen.


Het idee is dat er in elke dataset een veld is dat we kunnen gebruiken om de twee samen te voegen; in dit geval hebben we het ID-veld in `sthelens` en het ID-veld in `hp.data`.


```{r}
RotterdamStaatHER<-rename(RotterdamStaat, BUURTNAAM = buurtenrotterdam) 
```


```{r}
RotterdamTOT<-merge(Rotterdam, RotterdamStaatHER)
```

Gebruik de head-functie om te controleren of de gegevens correct zijn samengevoegd.

```{r}
head(RotterdamTOT)
```

Nu we de gegevens hebben samengevoegd, kunnen we een kaart maken van deze huizen-prijzen.


```{r}
qtm(RotterdamTOT, fill="NNGB")
```


Dit is een zeer snelle manier om een kaart met R te maken. Om de kaart te gebruiken, klikt u op de `Export`-knop en kiest u vervolgens voor `Copy` naar `Clipboard`. . . . Kies vervolgens `Copy Plot`. Als je ook Word hebt, kun je de kaart in je document plakken. Je kunt de kaart ook opslaan als Afbeelding of PDF.

Een Kaart maken Census Data

Werken met R vereist vaak meerdere coderegels code om een output te krijgen. In plaats van de code in de **Console** in te typen, kunnen we in plaats daarvan een script gebruiken. Daar kunnen we altijd naar teruggaan en de code zeer eenvoudig te bewerken, om fouten te corrigeren!

Maak een nieuw script aan (**File > New File > R-script**) en voer de code daar in. Vervolgens kunt je de regels die je wilt uitvoeren selecteren door ze te markeren en vervolgens op Ctrl+Enter te drukken, of door de **Run** knop bovenaan te gebruiken.

Nu gaan we hetzelfde principe gebruiken als voorheen om een kaart te maken van enkele gegevens uit 2018. We moeten de gegevens eerst downloaden. 


- Ga naar https://www.cbs.nl/nl-nl/dossier/nederland-regionaal/wijk-en-buurtstatistieken/kerncijfers-wijken-en-buurten-2004-2019.
- Open vervolgens https://www.cbs.nl/nl-nl/maatwerk/2018/30/kerncijfers-wijken-en-buurten-2018. 
- sla het bestand kwb-2018.xls op in map Buurtexcel.

```{r}
library(readxl)
GegBuurten<-read_excel("kwb-2018.xls")
```


Dan gebruik je de `head`-functie om te zien of de data goed zijn ingelezen. *R laat alle 23 variabelen zien, terwijl je in deze handout je alleen maar de eerste zes ziet.*

```{r}
head(GegBuurten)
```

Sommige variabelenamen worden niet duidelijk weergegeven. We kunnen de kolommen hernoemen, zodat wanneer we de `head`-commando uitvoeren, R de juiste namen weergeeft. Dit zal ons ook helpen om later naar de kolommen te verwijzen.

Voer onderstaande code uit, die een nieuwe variabele maakt die de namen ('newcolnames') bevat en deze vervolgens toepast op het pop2011-dataframe.


*Het is ook goed om hier op te merken dat elke coderegel die begint met een # een commentaar is - d.w.z. dat R die regel zal negeren en naar de volgende regel zal gaan. Ik heb ze hier opgenomen zodat je kunt zien wat er aan de hand is, maar je hoeft ze niet in te typen.*


*Ga naar de volgende. Ik heb ze hier opgenomen zodat je kunt zien wat er aan de hand is, maar je hoeft ze niet in te typen.*

De laatste coderegel (start colnames) werkt de namen van de variabelen bij. De vierkante haakjes worden gebruikt om te verwijzen naar specifieke elementen - in dit geval, kolommen 5 tot 23. *Bijvoorbeeld, pop2011[1,] toont de eerste rij en pop2011[,1] toont de eerste kolom.*

Nu hebben we de juiste kolomnamen voor het dataframe. Het zou ook goed zijn om te controleren of ze correct zijn toegepast op het pop2011 dataframe. **Welke code zou je gebruiken om dit te doen?*


Nu we de attribuutgegevens (in dit geval kijken we naar het percentage koopwoningen) hebben, moeten we deze attribuutgegevens toevoegen aan de ruimtelijke gegevens. Daarom moeten we eerst de ruimtelijke gegevens downloaden.

- Ga naar https://www.cbs.nl/nl-nl/dossier/nederland-regionaal/geografische-data/wijk-en-buurtkaart-2018.
- Download wijk en buurtkaart. 
- Sla het op in een map (zoals hier Wijkenbuurt)
- en hij heet buurt_2018.v2.shp

Lees vervolgens de gegevens in:


```{r}
#Lees de shapefile in
Buurten <- st_read("buurt_2018_v2.shp")

```


```{r}
qtm(Buurten)
```


Vervolgens halen we eerst Rotterdam uit de twee totaalbestanden.


```{r}
BuurtenRot<-filter(Buurten, GM_NAAM=="Rotterdam")
```


```{r}
GegBuurtenRot<-filter(GegBuurten, gm_naam=="Rotterdam")
```


Vervolgens hernoemen we regio tot BU_AAM zoals in het shapefile bestand
```{r}
GegBuurtenRotHER<-rename(GegBuurtenRot, BU_NAAM = regio) 
```

De volgende stap is om de attribuutgegevens aan de ruimtelijke gegevens toe te voegen. Daarom gaan we beide bestanden mergen. Lees het ook in als sf-bestand

```{r}
GegBuurtenRotTOT<-merge(GegBuurtenRotHER, BuurtenRot)
GegBuurtenRotTOT <- st_as_sf(GegBuurtenRotTOT)
```

En we gebruiken het hoofd-commando om te controleren of de koppeling goed is verlopen. Jouw data moet de goed gelabelde 'Age'-data in de 7de tot 26ste kolom bevatten.

```{r}
head(GegBuurtenRotTOT)
```

Laat nu Rotterdam zien

```{r}
qtm(GegBuurtenRotTOT)
```



Laten we ook de variabele percentage koopwoning afbeelden.

```{r}
qtm(GegBuurtenRotTOT, fill="p_koopw")
```


```{r}
tm_shape(GegBuurtenRotTOT) + 
        tm_polygons("p_koopw")
```



## Kaarten maken
Nu we alle data hebben ingesteld, kunnen we de kaart daadwerkelijk maken. We kunnen de `qtm`() code gebruiken, net zoals we eerder deden.

We kunnen de `fill`parameter gebruiken zoals we eerder deden met de inbraakgegevens. Probeer de code zelf uit te werken om de eerste set leeftijdsgegevens te tonen.

Dit werkt goed, en we kunnen kiezen welke variabele we willen tonen. Maar we krijgen hier niet veel opties mee. We kunnen een andere functie `tm_shape`() gebruiken, die ons meer opties geeft.

```{r}
tm_shape(GegBuurtenRotTOT) + 
        tm_polygons("p_koopw")
```



```{r}
tm_shape(GegBuurtenRotTOT) +
tm_polygons("p_koopw",  title  =  "Percentage koopwoningen",  palette  =  "Greens",  style  =  "jenks")  + tm_layout(legend.title.size = 0.8)
```

Dit stelt ons in staat om de titel, de kleuren en de grootte van de legende te veranderen. Probeer Blues te vervangen in Blues en de titel aan te passen.

## Kleuren en categoriën

We kunnen kiezen uit veel verschillende kleuren van `ColorBrewer`, en ook verschillende indelingsmethoden. Om alle verschillende kleurenpaletten te tonen die we kunnen gebruiken, kunt u deze code gebruiken:

```{r}
tm_shape(GegBuurtenRotTOT) +
        tm_polygons("p_koopw",  title  =  "Percentage koopwoningen",  palette  =  "Greens",  n  =  6,  style  =  "jenks")
```

We kunnen ook de stijl instellen die de indelingsmethode is. Standaard opties zijn:

Classificatie Naam	Code	Details of Voorbeeld   
 
Gelijk Interval	        equal	**Gelijke intervallen bv 0-5, 5-10, 10-15, 15-20**   
Quantielen	        quantiel**Deel de data op in 5 equal categorieen, met hetzelfde aantal datapunten in elke categorie**   
Natuurlijke Breuken	jenks	**Algoritme om datagedreven categorien te maken**   
Standaard Deviatie	sd	**Baseert klassen op data standaard deviatie bv -2SD naar -1SD, -1SD naar 0, 0 naar 1SD, 1SD naar 2SD**    
Vaste Breuken	        fixed	**Jij kiest de breuken  - zie hieronder**    


Vast breuken voorbeeld:

```{r}
tm_shape(GegBuurtenRotTOT) +
tm_polygons("p_koopw",  title  =  "Percentage koopwoningen",  palette  =  "Greens",  n  =  6,  style  =  "fixed", breaks=c(15.57,  25,  50,  75,  100,  155.30))

```
## Histogrammen

We kunnen ook een histogram van de gegevens aan de kaart toevoegen:

```{r}
tm_shape(GegBuurtenRotTOT) +
tm_polygons("p_koopw",  title  =  "Percentage koopwoningen",  palette  =  "Greens", style = "equal", legend.hist = T)
```

## Schaalbalk en een pijl naar het Noorden

Het is ook een goede gewoonte om een schaalbalk en een pijl naar het noorden toe te voegen aan de kaarten die je maakt. Als je deze code runt worden die aan de kaart toegevoegd.

```{r}
tm_shape(GegBuurtenRotTOT) +
#Stel kleuren en classificatiemethodes in
tm_polygons("p_koopw",  title  =  "Percentage koopwoningen",  palette  =  "Greens", style = "equal") +
#Voeg schaalbalk toe
tm_scale_bar(width  =  0.22,  position  =  c(0.05,  0.18))  +
#Voeg kompas toe
tm_compass(position  =  c(0.3,  0.07))  +
#Stel layout details in
tm_layout(frame  =  F,  title  =  "Rotterdam",  title.size  =  2, title.position  =  c(0.7,  "top"))
```

Mogelijk moet u de positie van de items op de kaart aanpassen. Probeer "tm_scale_bar positie" te googelen voor informatie over hoe dit te doen.

Vergeet niet dat elke regel die begint met een # een commentaar is, en zal worden genegeerd door R. Commentaar is erg nuttig voor ons om op te merken wat de code doet, vooral als je er 6 maanden later op terugkomt en je je niet kunt herinneren wat het moet doen!

## Exporteren en het maken van meerdere kaarten
We kunnen de kaart automatisch opslaan als een bestand door het kaartobject aan te maken als een nieuwe variabele (m) en het vervolgens op te slaan met tmap_save(m).

```{r}
#Creëer de kaart
m <- tm_shape(GegBuurtenRotTOT) +
tm_polygons("p_koopw",  title  =  "Percentage koopwoningen",  palette  =  "Greens", style = "equal") +
tm_scale_bar(width  =  0.22,  position  =  c(0.05,  0.18))  + tm_compass(position  =  c(0.3,  0.07))  +
tm_layout(frame  =  F,  title  =  "Rotterdam",  title.size  =  2, title.position  =  c(0.7,  "top"))
#Sla de kaart op
tmap_save(m, "GegBuurtenRotTOT.png")
```

Door de kaart op te slaan met behulp van een code kunnen we heel eenvoudig meerdere kaarten maken. Een variabele (mapvariables) wordt gebruikt om een lijst te maken van de variabelen die in kaart moeten worden gebracht en dan begint de lijn die begint met een lus. Probeer de code uit te voeren en verander dan de variabelen die het in kaart brengen.


```{r}
#Stel eerst vast welke variabelen in de kaart komen
mapvariables  <-  c("a_inw",  "a_00_14",  "a_geb")
#Loop door elk van die kaarten
for (i in 1:length(mapvariables)) {
#Definieer de kaart 
m <- tm_shape(GegBuurtenRotTOT) +
#Stel de variabelen, kleuren en klassen vast
tm_polygons(mapvariables[i], palette = "Greens", style = "equal") +
#Stel de schaalbalk vast
tm_scale_bar(width  =  0.22,  position  =  c(0.05,  0.18))  +
#Stel het kompas in
tm_compass(position  =  c(0.3,  0.07))  +
#Stel de layout vast
tm_layout(frame  =  F,  title  =  "Rotterdam",  title.size  =  2, title.position  =  c(0.7,  "top"))
#Sla de kaart op
tmap_save(m, filename = paste0("map-",mapvariables[i],".png"))
#Einde van de loop
}
```

Je kunt .png veranderen in .jpg of .pdf voor andere fileformaten.

## Creëer een eenvoudige kaart titel (optionele oefening)
Zoals je misschien hebt gezien, zijn de kaart- en legendetitels niet geweldig. Alleen al het gebruik van de veldnaam geeft ons de informatie die we nodig hebben. Het garandeert nog niet dat de kaart er goed uitziet.

Hoe kunnen we een betere kaarttitel maken?

Doe een experiment en kijk of je het kunt uitwerken. Er is wat code beschikbaar (in script-examples/script-multiple-maps) maar probeer niet meteen te kijken!


 
## Referenties

Nick Bearman. *Introduction to Spatial Data & Using R as a GIS*. https://github.com/nickbearman/intro-r-spatial-analysis/blob/master/workbook.pdf

Lovelace, R., Nowosad, J. and Muenchow, J. *Geocomputation with R*. https://geocompr.github.io/


---

Deze 'practical' is geschreven met R 3.5.1 (2018-07-02) en RStudio 1.1.463 door Dr. Nick Bearman (nick@ geospatialtrainingsolutions.co.uk).

Het werk is gelicenseerd onder Creative Commons Attribution-ShareAlike 4.0 International License. Om een kopie van deze licentie te zien, ga dan naar http://creativecommons.org/licenses/by-sa/4.0/deed.en. De laatste PDF-versie kun je hier https://github.com/nickbearman/intro-r-spatial-analysis vinden. Deze versie is op 18 May 2019 gemaakt.

